## 数组

数组：将多个元素(通常是同一类型)按一定顺序排列放到一个集合中，那么这个几个我们就称之为数组。

##### 创建数组

```js{cmd=node}
// 创建数组
var arr = [];
// 创建包含多个数据的数组，数据类型不受限制
var arr2 = [1,true,null,undefined,[7,8],'哈哈'];
// 获取arr2的第三项
console.log(arr2[2]);
// 获取数组长度
console.log(arr.length)
```

##### 获取数组元素

可以通过index来获取对应的某一项的数据，进行下一步操作。

如果索引值超过数组最大项，相当于这一项没有赋值，内部存储的就是undefined。

##### 数组的长度(length属性)

可以操作length拉长或缩短数组长度。

可以定义一个比长度大的索引的值来拉长数组，其中，为定义值的均为undefined

缩短后相当于把元素删除，操作不可逆。

##### 数组的遍历

对数组的每一个元素都访问一遍，使用for循环。

0~arr.length-1
```js{cmd=node}
var arr = [22,45,63,82,97];
// 遍历数组
for(var i = 1;i < arr.length;i++) {
    console.log(arr[i]);
}
```

## 函数

封装一段代码，将来可以重复使用。被封装起来的函数具备某一项特殊的功能，内部封装的一段代码作为一个完整的结构体，要执行就都执行，要不执行就都不执行。 
```js{cmd=node}
function fun() {
    console.log(1);
}
```

##### 函数声明

函数必须先定义后使用。
```js{cmd=node}
function fun(参数) {
    // 封装的结构体

}
// 函数调用
fun();
```

##### 函数调用

一次调用，多次执行。

函数内部语句执行的位置，与函数定义的位置无关，与函数调用位置有关。

##### 函数的参数

参数是局部变量，只能在函数内部使用。

希望函数执行结果可以根据自定义的内容发生一些变化。

函数的参数可以让用户自定义内容，可以接收任意类型的数据，导致函数执行结果根据参数不同，结果也不同。

一个函数可以设置0个或多个参数，参数间使用，分隔。

###### 形参、实参

+---------------------------------------------------------------------------------------------+
|                                                                                             |
|                              形 参                                                            |
|                              ^                                                              |
|                              |                                                              |
|                              |                                                              |
|                function fun(a+b) {                                                          |
|                    console.log(a+b);                                                        |
|                }                                                                            |
|                fun(5,7);                                                                    |
|                  +                                                                          |
|                  |                                                                          |
|                  |                                                                          |
|                  v                                                                          |
|                  实 参                                                                        |
+---------------------------------------------------------------------------------------------+

形参：函数执行时，形参接收实参传递过来的数据，相当于给形参变量进行隐形的赋值过程，参与程序时，结构体中的变量会使用形参接收到的数据。

实参：函数调用时，会先传递给形参对应的位置。

变量部分用的就是形参接收到的实参的数据，整个过程就是传参过程。

形参和实参的个数可以不一样。

函数参数的优点：

1. 想要使用函数，只需知道传递什么参数，执行什么功能即可，不需要知道内部的结构。
2. 使用函数需要有一个API接口说明，告诉使用者参数需要传递什么类型的数据，实现什么功能。

##### 函数的返回值

函数能够通过参数接收数据，也能将函数执行结果返回一个值。

利用函数内部的return关键字设置返回值。

作用：

1. 函数内部如果结构体执行到一个return关键字，会立即停止后面代码的执行。
2. 可以在return关键字后面添加空格，空格后面任意定义一个数据字面量或者表达式，函数在执行完自身功能后，整体会被return矮化成一个表达式，表达式必须求出一个值可以继续参与程序，表达式的值就是return后面的数据。

注意：

​	如果函数没有设置return语句，name函数有默认的返回值undefined；如果函数使用return语句，但是return后面没有任何值，那么函数的返回值也是undefined。

##### 函数表达式
```js{cmd=node}
// 定义一个函数表达式
var a = function fun() {
    console.log(1);
};
var b = function() {
    console.log(2);
};
// 调用
b();
```

注意：

调用时必须使用**变量名**调用。

##### 函数的数据类型

function

函数是一种数据类型，可以参与其他程序。如：作为另一个函数的参数或返回值进行使用。

##### 函数的递归

函数内部可以通过函数名调用函数自身的方式，就是函数递归现象。

递归的次数太多容易出现错误，超出计算机的最大计算能力。

如：斐波那契数列

##### 作用域

函数作用域、全局变量、局部变量。

变量退出作用域后会被销毁，全局变量关闭网页或浏览器才会销毁。

###### 函数作用域

当函数b定义在函数a内部时，只能在函数a内使用，在外部不能调用函数b.

###### 作用域链

函数内部包含函数时，将所有的作用域列出来，就会形成一个作用域链。

###### 遮蔽效应

程序在遇到变量时，会按照由内而外的层级去查找变量，直到找到第一个变量定义。整个过程中会发生内层变量遮蔽外层变量的效果，叫做遮蔽效应。

##### 预解析

JavaScript解析器执行代码时，分为两个过程：预解析过程和代码执行过程。

###### 预解析过程

1. 把变量的声明提升到当前作用域的最前面，只提升声明，不提升赋值

2. 把函数的声明提升到当前作用域的最前面，只提升声明，不提升调用

3. 先提升var，再提升function

   若出现变量名和函数名同名，则函数会覆盖变量内容。

   如果同名函数覆盖同名变量之后，又对该标识符进行赋值操作，此时该标识符内容成为赋的值，再调用函数时，则会报错。

   因此，不要书写相同的标识符给变量和函数，避免出现覆盖。

4. 函数表达式进行的是变量的提升，在函数书写之前调用函数，数据类型会报错。

   因此，定义函数时，最好使用function关键字进行定义，这样函数声明提升可以永远生效。
```js{cmd=node}
// 先调用
console.log(a); // undefined
// 后定义
var a = 1;
```

###### 代码执行过程

在预解析之后，根据新的代码顺序，从上往下按照既定规律执行代码。

##### IIFE自调用函数

即时调用的函数表达式。函数在定义时就会立即调用。

函数表达式定义过程中，将一个函数矮化成了一个表达式，后面加()运算符就可以执行。

###### 方式：

1. 在函数前面添加操作符，将函数矮化成表达式（+ - ()  = !）

###### 优点：

1.IIFE关住了 函数作用域，在外部无法调用。

2.最常用的是()运算符，而且可以使用匿名函数。
```js{cmd=node}
(function(a) {
    console.log(a);
})(1);
```